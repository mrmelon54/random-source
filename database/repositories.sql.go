// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: repositories.sql

package database

import (
	"context"
	"time"
)

const addIndexedFile = `-- name: AddIndexedFile :execlastid
INSERT INTO files_index (repository_id, path, lines)
VALUES (?, ?, ?)
`

type AddIndexedFileParams struct {
	RepositoryID int64  `json:"repository_id"`
	Path         string `json:"path"`
	Lines        int64  `json:"lines"`
}

func (q *Queries) AddIndexedFile(ctx context.Context, arg AddIndexedFileParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, addIndexedFile, arg.RepositoryID, arg.Path, arg.Lines)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const addRepository = `-- name: AddRepository :exec
INSERT INTO repositories (name, branch, updated_at, indexed_at, had_error)
VALUES (?, ?, ?, 0, FALSE)
`

type AddRepositoryParams struct {
	Name      string    `json:"name"`
	Branch    string    `json:"branch"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) AddRepository(ctx context.Context, arg AddRepositoryParams) error {
	_, err := q.db.ExecContext(ctx, addRepository, arg.Name, arg.Branch, arg.UpdatedAt)
	return err
}

const getNonProcessedRepo = `-- name: GetNonProcessedRepo :one
SELECT id, name, branch, updated_at, indexed_at, had_error
FROM repositories
WHERE indexed_at < updated_at
LIMIT 1
`

func (q *Queries) GetNonProcessedRepo(ctx context.Context) (Repository, error) {
	row := q.db.QueryRowContext(ctx, getNonProcessedRepo)
	var i Repository
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Branch,
		&i.UpdatedAt,
		&i.IndexedAt,
		&i.HadError,
	)
	return i, err
}

const randomIndexedFile = `-- name: RandomIndexedFile :one
SELECT id, repository_id, path, lines
FROM files_index
WHERE lines > ?
ORDER BY random()
LIMIT 1
`

func (q *Queries) RandomIndexedFile(ctx context.Context, lines int64) (FilesIndex, error) {
	row := q.db.QueryRowContext(ctx, randomIndexedFile, lines)
	var i FilesIndex
	err := row.Scan(
		&i.ID,
		&i.RepositoryID,
		&i.Path,
		&i.Lines,
	)
	return i, err
}

const updateIndexedAt = `-- name: UpdateIndexedAt :exec
UPDATE repositories
SET indexed_at = ?
WHERE id = ?
`

type UpdateIndexedAtParams struct {
	IndexedAt time.Time `json:"indexed_at"`
	ID        int64     `json:"id"`
}

func (q *Queries) UpdateIndexedAt(ctx context.Context, arg UpdateIndexedAtParams) error {
	_, err := q.db.ExecContext(ctx, updateIndexedAt, arg.IndexedAt, arg.ID)
	return err
}

const updateRepository = `-- name: UpdateRepository :exec
UPDATE repositories
SET branch=?,
    updated_at=?
WHERE name = ?
`

type UpdateRepositoryParams struct {
	Branch    string    `json:"branch"`
	UpdatedAt time.Time `json:"updated_at"`
	Name      string    `json:"name"`
}

func (q *Queries) UpdateRepository(ctx context.Context, arg UpdateRepositoryParams) error {
	_, err := q.db.ExecContext(ctx, updateRepository, arg.Branch, arg.UpdatedAt, arg.Name)
	return err
}
